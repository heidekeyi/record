* 杂谈
** 理念
   - 一个网站就是一个文件夹
   - 一个网页就是一个文件
** 概念
   - url 统一资源定位器
   - 网址：协议:域名[端口号][路径][文件名]

* debug 辅助函数
  - 显示时间信息
    #+BEGIN_SRC php
      echo date('Y-m-d H:i:s');
      echo idate('w'); // week info
	//时间戳
	var_dump(time());
	var_dump(microtime(true));
    #+END_SRC
  - 输出配置信息
    #+BEGIN_SRC php
      phpinfo();
    #+END_SRC
  - false/null/NULL没有输出 （null不区分大小写）
  - 控制台换行
    #+BEGIN_SRC php
      echo 'hello'.PHP_EOL;
      echo 'hello'.PHP_EOL;
    #+END_SRC
  - HTML中源码输出
    #+BEGIN_SRC php
      $fn = function (...$rest) {
	  return $rest;
      };
      //变量是内存地址
      //变量值才有类型
      echo '<pre>' . print_r($fn(1, 2), true) . '</pre>';
    #+END_SRC
  - 各种输出（适用不同对象）
    #+BEGIN_SRC php
      echo 'hello', 'world', '!';
      print 'hello';
      print 'world';
      print '!';
      var_dump('hello');
      var_dump('world');
      var_dump('!');
      //die、exit都可以退出程序
      die('die statement');
      exit('exit program');
    #+END_SRC

* base
** 自动、强制类型转换
   #+BEGIN_SRC php
     //自动类型转换
     //@是禁止警告的意思
     //基本类型相加都会转数字
     @var_dump('11' + '7abc'); // 18
     @var_dump('11' + 'abc'); // 11
     var_dump('11' + false); // 11
     var_dump('11' + true); // 12
     var_dump('11' + null); // 11
     var_dump(10.9 % 3.3); //1 (直接向下取整)
     $a = 'abc';
     @$a += 'abc';
     var_dump($a); //0

     //强制转换
     var_dump((int)'111'); //int 111
     var_dump((int)'abc'); //int 0
   #+END_SRC

** 三元运算符
   - $a ?? $b
     - $res = $_GET['a'] ?? 'a';
     - $res = isset($_GET['a']) ? $_GET['a'] : 'a';
   - $a ?: $b
     - $res = $_GET['a'] ?: '11';
     - $res = empty($_GET['a']) ? $_GET['a'] : '11';
** 导入文件
*** 使用方式和特点
    #+BEGIN_SRC php
      //相当于拷贝了三次文件的代码放到这
      //重复定义函数报错，但是代码会继续执行
      //include 和 require 类似，后者出错就停止往下执行 
      include './3scope.php';
      include './3scope.php';
      include './3scope.php';

      //相当于拷贝了一次
      //include_once 和 require_once 类似，后者出错就停止往下执行
      include_once './3scope.php';
      include_once './3scope.php';
      include_once './3scope.php';
    #+END_SRC
*** 文件不带路径查找规则
    1. php.ini 中 include_path 指定的路径找
    2. 当前目录找
    3. 导入文件所在目录找
*** 路径相关函数
    #+BEGIN_SRC php
      //当前文件的绝对地址
      var_dump(__DIR__);
      //当前访问页面的绝对路径
      var_dump(getcwd());
    #+END_SRC
** 上传文件
   - 客户端
     - method="post"
     - enctype="multipart/form-data"
     - <input name="token" value="...." type="hidden">
     - 多个文件注意点
       - <input type="file" name="fs[]"/>
       
   - 服务器
     - $_FILES 文件信息
       - 临时文件、错误状态、源文件名称之类的
       - 多个文件和单个文件格式时不一样的
     - is_uploaded_file 上传状态判断
     - 拼接文件名称（避免重复覆盖）
     - move_uploaded_file 保存文件（移动文件）
     #+BEGIN_SRC php
       //    文件信息，多个文件和单个文件格式时不一样的
       //    print_r($_FILES);
	   $ext = 'jpg';
       //    echo date('Ymdhis', time()) . md5(time()) . '.' . $ext;
	   if (is_uploaded_file('./tmp')) {
	       if (move_uploaded_file('./temp', './dest')) {
		   echo 'perms deny!';
	       }
	   } else {
	       echo 'upload failure!';
	   }
     #+END_SRC
* oop
** class
   - 接口是类的模板
   - 类是接口的实现
   - 类是对象的模板
   - 对象是类的实现
   - 继承多个接口扩展功能很方便
   - 必须实现接口中的方法
*** 基本知识点
    #+BEGIN_SRC php
      //public 没有访问限制
      //protected 定义类和子类可以访问
      //private 只有定义类可以访问
      //推荐类书写方式
      //先写不变的，在写变得，在写方法
      //1 类属性常量
      //2 类静态属性
      //3 变量
      //4 静态方法
      //5 构造析构方法
      //6 一般方法
      class A
      {
      //    类静态属性
	  const T = 'A';
	  public static $s = 'a';
      //    一般属性
	  public $a;
	  protected $b;
	  private $c;


      //    静态方法
	  public static function print()
	  {
      //        定义类属性
	      echo self::$s . self::T . PHP_EOL;
      //        实际调用类的属性
      //        静态延时绑定
      //        后期静态绑定
	      echo static::$s . static::T . PHP_EOL;
	  }

      //    魔术方法
      //    __call、__clone、__get ...
      //    还有很多，看手册
	  public function __construct($a, $b, $c)
	  {
	      $this->a = $a;
	      $this->b = $b;
	      $this->c = $c;
	  }

      //    一般方法
	  public function show()
	  {
	      echo $this->a
		  . $this->b
		  . $this->c;
	  }
      }


      //除了private访问权限外的成员都可以访问
      class B extends A
      {
	  const T = 'B';
	  public static $s = 'b';

	  public static function print()
	  {
	      parent::print(); // TODO: Change the autogenerated stub
	  }

	  public function __construct($a, $b, $c)
	  {
      //        初始化父类
	      parent::__construct($a, $b, $c);
	  }
      }

      B::print();
      //结果
      //aA
      //bB
    #+END_SRC
*** 继承
    - 普通方式
      #+BEGIN_SRC php
	class A
	{
	    public function add()
	    {

	    }
	}

	class B extends A
	{
	}
      #+END_SRC
    - 使用抽象类
      #+BEGIN_SRC php
	//抽象类
	abstract class A
	{
	    abstract public function mul();

	    public function show()
	    {

	    }
	}

	class B extends A
	{
	//    重写方法，不推荐
	    public function show()
	    {

	    }
	//必须实现抽象方法
	    public function mul()
	    {

	    }
	}
      #+END_SRC
    - 使用接口
      #+BEGIN_SRC php
	//接口中方法只是声明，不能有实现（函数体）
	interface A1
	{
	    public function add();
	}

	interface A2
	{
	    public function mul();
	}
	//可以使用多个接口
	//必须实现接口中的方法
	class B implements A1, A2
	{
	    public function add()
	    {

	    }

	    public function mul()
	    {

	    }
	}
      #+END_SRC
    - 使用trait
      #+BEGIN_SRC php
	class A
	{
	    public function add()
	    {
		echo 'A::add' . PHP_EOL;
		return $this;
	    }

	    public function mul()
	    {
		echo 'A::mul' . PHP_EOL;
		return $this;
	    }
	}

	//新增方法
	//为了方笔测试返回$this，实际看情况
	trait A1
	{
	    public function show()
	    {
		echo 'A1::show' . PHP_EOL;
		return $this;
	    }
	}

	//重新实现mul方法
	trait A2
	{
	    public function mul()
	    {
		echo 'A2::mul' . PHP_EOL;
		return $this;
	    }
	}

	//trait中的方法优先父类
	//相当于多继承
	//推荐A中放不修改的部分（相同的部分）
	//会变得部分使用trait，方便重新构造新类
	class B extends A
	{
	    use A1;
	    use A2;
	}

	(new B())->mul()->show()->add();
      #+END_SRC

** MVC
   - M: Model 数据库，主要针对器操作（CURD）
   - V: View 页面（HTML），用户看到的页面
   - C: Controller 控制器，模型和视图必须在控制器中调用
*** 依赖注入
    一般一个类一个文件，这里写一起为了方便
    #+BEGIN_SRC php
      namespace a;
      class Model
      {
	  public function fetchAll()
	  {
	      return ['a', '1', '.', 'd'];
	  }
      }

      namespace b;
      class View
      {
	  public function output($data)
	  {
	      return join('-*-', $data);
	  }
      }

      namespace c;

      use a\Model;
      use b\View;

      class Controller
      {
	  private $model;
	  private $view;

	  public function __construct(Model $model, View $view)
	  {
	      $this->model = $model;
	      $this->view = $view;
	  }

	  public function index()
	  {
	      $data = $this->model->fetchAll();
	      return $this->view->output($data);
	  }
      }

      namespace e;

      use a\Model;
      use b\View;
      use c\Controller;

      //依赖注入
      $c = new Controller(new Model(), new View());
      echo $c->index() . PHP_EOL;
    #+END_SRC

*** 使用容器
    Model View同依赖注入
    #+BEGIN_SRC php
      namespace cc;

      use a\Model;
      use b\View;

      class Container
      {
	  private $container = [];

	  public function __construct()
	  {
	      $this->bind(Model::class, function () {
		  return new Model();
	      });
	      $this->bind(View::class, function () {
		  return new View();
	      });
	  }

	  public function bind($alias, \Closure $closure)
	  {
      //        将类的实例化过程绑定/存入到容器中
	      $this->container[$alias] = $closure;
	  }

	  public function make($alias, ...$rest)
	  {
	      return call_user_func_array($this->container[$alias], $rest);
	  }
      }

      namespace c;

      use a\Model;
      use b\View;
      use cc\Container;

      class Controller
      {
	  public function index(Container $container)
	  {
	      $data = $container->make(Model::class)->fetchAll();
	      return $container->make(View::class)->output($data);
	  }
      }

      namespace e;
      //使用容器
      use c\Controller;
      use cc\Container;

      //依赖注入
      $c = new Controller();
      echo $c->index(new Container()) . PHP_EOL;
    #+END_SRC

*** 门面
    Model View Container同使用容器
    #+BEGIN_SRC php

      namespace f;

      use a\Model;
      use b\View;
      use cc\Container;


      //门面Facade， 外观模式， 静态代理
      //后面的可以继承扩展
      class Facade
      {
	  private static $container;

      //    初始化容器
	  public static function initialize(Container $container)
	  {
	      static::$container = $container;
	  }
      //    下面的方法将动态方法静态化
      //    这里以获取模型数据和视图显示为例
	  public static function fetchAll()
	  {
	      return static::$container->make(Model::class)->fetchAll();
	  }

	  public static function output($data)
	  {
	      return static::$container->make(View::class)->output($data);
	  }
      }

      namespace c;

      use a\Model;
      use b\View;
      use cc\Container;
      use f\Facade;

      class Controller
      {
	  public function __construct($container)
	  {
	      Facade::initialize($container);
	  }

	  public function index()
	  {
	      $data = Facade::fetchAll();
	      return Facade::output($data);
	  }
      }

      namespace e;
      //使用容器
      use c\Controller;
      use cc\Container;

      //依赖注入
      $c = new Controller(new Container());
      echo $c->index() . PHP_EOL;
    #+END_SRC

** 抽象工厂模式
   工厂模式使用接口就成了抽象工厂模式
   #+BEGIN_SRC php
     namespace b;

     trait P
     {
	 public function s(...$rest)
	 {
	     echo static::class . '--' . implode(',', $rest) . PHP_EOL;
	 }
     }

     namespace b;
     class A
     {
	 use P;

	 public function __construct(...$rest)
	 {
	     $this->s(...$rest);
	 }
     }

     class B
     {
	 use P;

	 public function __construct(...$rest)
	 {
	     $this->s(...$rest);
	 }
     }

     namespace c;

     use b\A as A;
     use b\B;

     //抽象工厂（实现接口或继承抽象类）
     interface iFactory
     {
	 public static function create($class_name, ...$rest);
     }

     class Factory implements iFactory
     {
	 public static function create($class_name, ...$rest)
	 {
	     return new $class_name(...$rest);
	 }
     }

     Factory::create(A::class, 1, 2);
     Factory::create(B::class, 'a', 'b');
   #+END_SRC
  
** 单例模式
   #+BEGIN_SRC php
     namespace a;
     //单例模式
     class A
     {
	 protected static $handle = null;

     //禁止外部实例化对象
	 protected function __construct()
	 {

	 }

	 public static function getInstance()
	 {
	     if (is_null(static::$handle)) {
		 static::$handle = new static();
	     }
	     return static::$handle;
	 }

     //    禁用clone方式创建对象
	 protected function __clone()
	 {
	     return static::getInstance();
	     // TODO: Implement __clone() method.
	 }
     }

     //true
     echo gettype(A::getInstance() === A::getInstance()) . PHP_EOL;
     //false
     //echo var_dump(A::getInstance() === clone A::getInstance()) . PHP_EOL;
   #+END_SRC

** 回调函数
   #+BEGIN_SRC php
     namespace query;
     //查询构造器
     class Query
     {
	 private $table = '';
	 private $limit = '';
	 private $field = '';
	 private $where = '';

	 public function table($table_name)
	 {
	     $this->table = $table_name;
	     return $this;
	 }

	 public function field($field_string)
	 {
	     $this->field = $field_string;
	     return $this;
	 }

	 public function limit($num)
	 {
	     $this->limit = ' limit ' . $num;
	     return $this;
	 }

	 public function where($condition)
	 {
	     $this->where = ' where ' . $condition;
	     return $this;
	 }

	 public function select()
	 {
	     return 'select ' .
		 $this->field .
		 ' from ' .
		 $this->table .
		 $this->where .
		 $this->limit;
	 }
     }


     namespace n;
     use query\Query;
     class Db
     {
     //    静态回调
	 public static function __callStatic($name, $arguments)
	 {
	     // TODO: Implement __callStatic() method.
	     return call_user_func_array([new Query(), $name], $arguments);
	 }
     }

     namespace m;
     use n\Db;
     echo Db::table('tb1')
	     ->field('*')
	     ->where('id > 1')
	     ->limit(10)
	     ->select() . PHP_EOL;
   #+END_SRC
** 类的自动加载
   - 创建./lib/Math.php文件（被使用类的文件）
   - 被使用类的文件名和类名词紧耦合，有规律
   - 被使用类的文件中的命名空间与路径对应
   #+BEGIN_SRC php
     namespace a;
     define('DS', DIRECTORY_SEPARATOR);
     //标准PHP库
     spl_autoload_register(function ($class_name) {
	 $path = __DIR__ . DS . str_replace('\\', DS, $class_name) . '.php';
	 if (file_exists($path)) {
	     include_once $path;
	 }
     });

     echo \lib\Math::add(1, 2) . PHP_EOL;
   #+END_SRC

** 单例模式
   #+BEGIN_SRC php
     namespace a;
     //单例模式
     class A
     {
	 protected static $handle = null;
     //    禁止外部实例化对象
	 protected function __construct()
	 {
	 }

	 public static function getInstance()
	 {
	     if (is_null(static::$handle)) {
		 static::$handle = new static();
	     }
	     return static::$handle;
	 }

     //    禁用clone方式创建对象
	 protected function __clone()
	 {
	     return static::getInstance();
	 }
     }
   #+END_SRC

* db
** 基本使用
   - 推荐pdo（PHP数据对象，数据库统一接口）
   - mysqli库之类的库（不同数据库使用不同的库）
   - pdo中尽量使用预处理减少注入
   - pdo基本使用例子
     #+BEGIN_SRC php
       $driver = 'mysql';
       $host = '127.0.0.1';
       $port = 3306;
       $db_name = 'db1';
       $charset = 'utf8';
       $username = 'root';
       $password = '';
       $dsn = "{$driver}:$host;port={$port};dbname={$db_name};charset=${charset}";
       try {
	   $pdo = new PDO($dsn, $username, $password);
       //print_r($pdo);
       //使用异常形式来提示错误
	   $pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
	   $sql = "insert into user (name ,password) values (:name, :password);";
       //    使用预处理方式执行sql
	   $sth = $pdo->prepare($sql);
       //    会过滤一些字符串类似注入之类的
	   $sth->bindValue(':name', '小李');
	   $sth->bindValue(':password', 'hello');
	   $sth->execute();
	   var_dump('exec success');
	   var_dump($pdo->lastInsertId('id'));
	   $sql = "select * from user order by id desc limit 0, 1;";
	   $data = $pdo->query($sql);
	   var_dump($data->fetchAll(PDO::FETCH_ASSOC));
       } catch (Exception $e) {
	   print_r($e->getMessage());
       //    var_dump($pdo->errorInfo());
       //    var_dump($pdo->errorCode());
       }
     #+END_SRC
** 表和Model类映射
   - 数据库需要有对应字段的表
   #+BEGIN_SRC php
     namespace a;

     use PDO;

     class T1
     {
	 private $id;
	 private $name;
	 private $department;
	 private $salary;
	 private $age;

	 public function __construct()
	 {
     //        修改列的显示
	     $this->id = 'NO-' . $this->id;
	 }

	 public function __set($name, $value)
	 {
	     // TODO: Implement __set() method.
	     $this->$name = $value;
	 }

	 public function __get($name)
	 {
	     // TODO: Implement __get() method.
	     return $this->$name;
	 }
     }

     $dsn = 'mysql:' .
	 'localhost' .
	 ';port=3306' .
	 ';dbname=db1' .
	 ';charset=utf8';
     //实例化（连接）
     $pdo = new PDO($dsn, 'root', '');
     $stmt = $pdo->prepare('select * from t1');
     if ($stmt->execute()) {
	 $res = $stmt->fetchAll(PDO::FETCH_CLASS, T1::class);
	 echo $res[0]->id . '-*-' . $res[0]->name . PHP_EOL;
     } else {
	 echo 'exe error' . PHP_EOL;
     }
   #+END_SRC
* route
  一个自定义路由的小测试
  #+BEGIN_SRC php
    //路由的简单例子
    //还有很多问题要处理
    namespace Admin;

    class User
    {
	public function add($param)
	{
	    echo 'name = ' . $param['name']
		. '------'
		. '    salary = ' . $param['salary'];
	}
    }

    //路由
    // /db.php/Admin/user/add/name/Alex/salary/1000;
    $uri = ltrim($_SERVER['REQUEST_URI'], '/');
    $arr = explode('/', $uri);


    //获取参数
    $rest = array_splice($arr, 4, 4);
    $param = [];
    for ($i = 0; $i < count($rest); $i += 2) {
	$param[$rest[$i]] = $rest[$i + 1];
    }

    //文件+模块+控制器+方法+[参数]
    //拼接类名
    list(, $module, $controller, $method) = $arr;
    $module = ucwords($module);
    $controller = ucwords($controller);
    $class_name = $module . '\\' . $controller;
    //动态实例化，调用对应的方法
    (new $class_name)->$method($param);
  #+END_SRC
* 错误
** 一些系统表示错误的常量
   例如：E_NOTICE、E_PARSE、E_WARNING、E_ERROR，都是整数值
** 用户错误
   例如：E_USER_ERROR等和上面的类似（中间多了 user）
** 触发用户错误
   #+BEGIN_SRC php
     trigger_error('触发的错误', E_USER_ERROR);
   #+END_SRC
** 系统级错误配置
   在 PHP 配置文件 php.ini 中修改
   #+BEGIN_SRC conf
     # 显示所有错误
     error_reporting = E_ALL
     # 只显示指定错误
     error_reporting = E_NOTICE | E_PARSE
     # 开启或关闭错误显示
     display_error On | Off
     # 日志文件
     errors_log = filename
     # 开启或关闭日志
     log_errors = On | Off
   #+END_SRC
** 文件级别的错误设置
   #+BEGIN_SRC php
     //错误信息
     //1 on 2 off
     ini_set('display_errors', 1);
     ini_set('error_reporting', E_NOTICE | E_PARSE);

     //日志
     //1 on 2 off
     ini_set('log_errors', 1);
     ini_set('error_log', './error.log');
   #+END_SRC
** 自定义错误
   致命错误是系统处理，用户无权接管
   #+BEGIN_SRC php
     set_error_handler('my_error');
     function my_error($code, $msg, $file,$line){
	 echo "<div>
     <p>错误码：$code</p>
     <p>错误信息：$msg</p>
     <p>触发文件：$file</p>
     <p>所在行：$line</p>
     </div>";
	 var_dump($code.$msg.$file.$line);
     }

     echo $a;
   #+END_SRC
* 异常处理
** 传统处理错误方式
   die 提示错误（结束程序）
** 使用异常类
   #+BEGIN_SRC php
     namespace e;

     use Exception;

     class MyException extends Exception
     {
	 public function __construct($message = "", $code = 0)
	 {
	     parent::__construct($message, $code);
	 }

     //    public function __toString()
	 public function errorInfo()
	 {
	     return 'msg: ' .
		 $this->getMessage()
		 . PHP_EOL
		 . 'code: '
		 . $this->getCode()
		 . PHP_EOL;
	 }
     }

     namespace s;

     use e\MyException;

     function init()
     {
	 throw new MyException(__FILE__ . ' line: ' . __LINE__, 1100);
     }

     namespace r;

     use s;
     use e\MyException;

     try {
	 s\init();
     } catch (MyException $e) {
     //    echo $e . PHP_EOL;
	 echo $e->errorInfo();
     }
   #+END_SRC
* 正则表达式
  preg:_ 开始的函数
  #+BEGIN_SRC php
    //值匹配一次，第三个参数保存结果
    preg_match('/a/i', 'AaA', $ret);
    print_r($ret);
    //类似'/a/ig'效果
    preg_match_all('/a/i', 'AaA', $ret);
    print_r($ret);
  #+END_SRC
* 接口  
  - php 类与类之间的接口
  - api 接口
    - 给小程序、app使用
    - 还可以给其它平台的php， 鞭它语言 python java
  - 一般使用json格式
  #+BEGIN_SRC php
    $json = json_encode([1 => 'a']);
    echo $json . PHP_EOL;
    print_r(json_decode($json, true));
  #+END_SRC
